#define _CRT_SECURE_NO_WARNINGS
#include<stdio.h>

//接上一节 单目操作符
//~
//int main()
//{
	//int a = 0;
	//000000000000000000000000000000000000 非负三码相同！！
	//~a
	//111111111111111111111111111111111111-  补码
	//111111111111111111111111111111111110 -反码
	//100000000000000000000000000000000001- 原码
	/*printf("%d\n", ~a);*///打印出的值是原码的值 结果为-1
//	
//}

//~的作用
//int main()
//{
	/*int a =13 ;*/
	//000000000000000000000000000000001101
	//如果想要将第二位变成1
	//000000000000000000000000000000001111
	//方法：  a | 000000000000000000000000000000000010  按位或
	//但是000000000000000000000000000000000010怎么表达或者说怎么得到?
	//1<<n  n由你想将第几位变成1减去1得到，例如上面题目是第二位，则是n=2-1
/*	a = a | (1 << 1);*///左移多少位由你想将第几位变成1

	//如果你又想变回来
	//000000000000000000000000000000001111
	//111111111111111111111111111111111101
	//变成
	//000000000000000000000000000000001101
	// 方法： a & 111111111111111111111111111111111101
	//但是111111111111111111111111111111111101怎么得到？
	// ~(1<<n)  n的值同上
//	a = a & (~(1 << 1));
//	printf("%d\n", a);
//}


//~在多组输入中的作用
//int main()
//{
//	//因为scnaf读取失败返回EOF，而EOF的值位-1，~-1=0即为假
//	while (~scnaf(......))
//	{
//		......;
//	}
//}

//++ --

//int main()
//{
//	//--同理
//
//	//int a = 10;
//	//int b = a++;
//	//printf("a=%d b=%d\n", a, b);//后置++ 先使用 后++
//	
//	//int a = 10;
//	//int b = ++a;
//	//printf("a=%d b=%d\n", a, b);//前置++，先++ 后使用
//	//printf("%d\n", ++a);
//	return 0;
//}


//()强制类型转换,最好在最初使用就写好类型,避免使用,万不得已可以一用
//int main()
//{
//	int a = (int)3.14;
//	return 0;
//}

//sizeof
//void test(int arr[])
//{
//	printf("%d\n", sizeof(arr));//结果为4/8  这里是地址
//
//}
//void test2(char ch[])
//{
//	printf("%d\n", sizeof(ch));//结果为4/8  这里是地址
//}
//int main()
//{
//	int arr[10] = { 0 };
//	char ch[10] = { 0 };
//	printf("%d\n", sizeof(arr));//结果为40
//	printf("%d\n", sizeof(ch));//结果为10
//	test(arr);
//	test2(ch);
//	return 0;
//}

//关系运算符 : 没啥好讲的~~  注意等号==不是什么都可以用相等判断
//有些东西不能用 == 比较  例如 字符串要用strcmp 

//逻辑操作符  && || 
//int main()
//{
//	int a = 2;
//	int b = 3;
//	int c = 0;
//	int d = 0;
//	printf("%d\n", a&&b);
//	printf("%d\n", a&&c);
//	printf("%d\n", a || c);
//	printf("%d\n", d || c);
//	//0为假，非0为真，系统返回常用1作为真
//	return 0;
//}
//判断闰年的时候用过

//比较经典的笔试题  逻辑操作特点：短路操作
//int main()
//{
//	int i = 0, a = 0, b = 2, c = 3, d = 4;
//	//i = a++&&++b&&d++;//因为a++结果就是0，而对于&&有一个为0则为假，所以后面都不算了  结果i=0 a=1
//	//printf(" a=%d\n b=%d\n c=%d\n d=%d\n ", a, b, c, d);//1 2  3 4
//	//printf(" %d\n", i);
//	//return 0;
//
//	i = a++||++b||d++;//因为a++为 0 ，继续往下 ++b为3  结束了，有一个为真返回真  所以i=1 ,a=1,b=3 
//	printf(" a=%d\n b=%d\n c=%d\n d=%d\n ", a, b, c, d);// 1 3 3 4
//}

//条件操作符, C语言唯一三目操作符
//int main()
//{
//	int a = 4;
//	int b = 0;
//	if (a > 5)
//		b = 3;
//	else
//		b = -3;
//	可以写成
//	b = ((a > 5) ? (3) : (-3));
//	return 0;
//}
//
//逗号表达式
//int main()
//{
//	int a = 1;
//	int b = 2;
//	int c = (a > b, a = b + 10, a, b = a + 1);
//	printf("%d\n", c);
//	//逗号表达式都会计算，但返回的结果是最后一个表达式的结果
//	if (a=b+1,c=a/2,d>0)
//}

//逗号表达式用途：
//int main()
//{
//	int a;
//	a = text();
//	text2(a);
//	while (a>0)
//	{
//		//进行某特定处理
//		a = text();
//		text2(a);
//	}
//
//	//就可以写成
//
//	int a;
//	while (a = text(), text2(a),a > 0)
//	{
//		//进行某特定处理
//	}
//	return 0;
//}

//下标引用、函数调用操作符

//int arr[10];
//arr[9]=10;
//[]的操作数为arr和9

//void test()
//{
//	printf("hehe\n");
//}
//void Add(int a, int b)
//{
//	printf("%d\n", a + b);
//}
//int main()
//{
//	test();
//	Add(2, 3);
//	return 0;
//	//函数调用操作符()至少有一个操作数
//	//函数类型可以省略，但是省略默认返回int ,所以还是养成好习惯，写上
//}

//结构成员
//  .   结构体.成员名
//  ->  结构体指针 -> 成员名
//struct Stu
//{
//	char name[20];
//	int age;
//	char sex[5];
//};
//int main()
//{
//	struct Stu s = { "zhangsan",20,"nan" };
//	printf("%s\n", s.name);
//	printf("%d\n", s.age);
//	printf("%s\n", s.sex);
//
//	//通过指针
//	struct Stu *ps = &s;
//	printf("%s\n", (*ps).name);//比较繁琐
//	printf("%s\n", ps->sex);//简化
//}

//int main()
//{
//	int a = 3 + (2 - 4) * 5;
//	int b = 3 + 5 + 6;
//	// 操作符优先级与结合性
//	// 笔记有表格
//}

//隐式类型转换
//整型提升：提升大小小于整形的数据类型 例如：字符，短整型
//这也是因为CPU内的整形运算器的操作数字节长度一般为int的字节长度，也是CPU通用寄存器长度
//所以要将小小于整形的数据类型整型提升才可以送进CPU计算
//int main()
//{
//	//char --> signed char （有符号的）
//	char a = 3;
//	//00000000000000000000000000000011
//	//但是a存于char类型
//	//故a为00000011
//	char b = 127;
//	//00000000000000000000000001111111
//	//但是b存于char类型
//	//故b为01111111
//	char c = a + b;
//	//a和b的大小不够一个整形大小，所以要发生整形提升
//	//整型提升是按照变量原符号位来提升的~
//	//a的整形提升：00000000000000000000000000000011
//	//b的整形提升：00000000000000000000000001111111
//	//结果为：	  00000000000000000000000010000010
//	//截断：10000010 存放与c中
//	printf("%d", c );//结果为-126
//	//%d -按有符号整形打印的
//	//又要整型提升
//	//11111111111111111111111110000010  补码
//	//11111111111111111111111110000001  反码 （补码-1） 
//	//10000000000000000000000001111110  原码  -126
//	return 0;
//}	
//

//整型提升实例一
//int main()
//{
//	char a = 0xb6;
//	//  0xb6 :    1011 0110  符号位为1
//	short b= 0xb600;
//	//b符号位也为1
//	int c = 0xb6000000;
//	if (a == 0xb6)//关系运算也会发生整型提升
//		printf("a");
//	if (a == 0xb600)//同理也会整型提升，因为short比int小
//		printf("b");
//	if (a == 0xb6000000)//不会整型提升
//		printf("c");
//	return 0;
//}

//整型提升实例二
//int main()
//{
//	char c = 1;
//	printf("%u\n", sizeof(c));
//	printf("%u\n", sizeof(+c));//算术运算 所以要整形提升
//	printf("%u\n", sizeof(-c));//算术运算 所以要整形提升
//}

//int fun()
//{
//	static int count = 1;
//	return ++count;
//}
//int main()
//{
//	int answer;
//	answer = fun() - fun()*fun();
//	printf("%d\n", answer);
//	return 0;
//	//这个代码是有问题的，无法确定那个fun()先计算，不同编译器结果可能不同！
//}

int main()
{
	int i = 1;
	int a = (++i) + (++i) + (++i);
	printf("%d\n", a);
	//这个代码也是有问题的，无法确定第三个++和第一个+先后顺序
	return 0;
}

//练习：编程实现：两个int（32位）整数m和n的二进制表达中，有多少个位(bit)不同？ 
#include<stdio.h>
//int main()
//{
//	int m, n;
//	int count = 0, i = 0;
//	scanf("%d%d", &m, &n);
//	int c = m ^ n;
//	for (i = 0; i < 32; i++)
//	{
//		if (((c >> i) & 1) == 1)
//			count++;
//	}
//	printf("%d", count);
//	return 0;
//}




//练习：获取一个整数二进制序列中所有的偶数位和奇数位，分别打印出二进制序列
//int main()
//{
//	int a,i,j,k;
//	int arr1[16] = { 0 }, arr2[16] = { 0 };
//	scanf("%d", &a);
//	for ( i = 0,j=0,k=0; i <32; i++)
//	{
//	
//		if (i==0)
//		{
//			arr1[j] = a & 1;
//			j++;
//		}
//		else if (i % 2 == 1)
//		{
//			arr2[k] = a & 1;
//			k++;
//		}
//		else if (i % 2 == 0)
//		{
//			arr1[j] = a & 1;
//			j++;
//		}
//		a = a >> 1;
//	}
//	printf("奇数位：(位数越高越往左)\n");
//	for (i = 15; i >= 0; i--)
//	{
//		printf("%d ", arr1[i]);
//	}
//	putchar('\n');
//	printf("偶数位：(位数越高越往左)\n");
//	for (i = 15; i >= 0; i--)
//	{
//		printf("%d ", arr2[i]);
//	}
//	return 0;
//}
//
////优化
//void Printbit(int num)
//{
//	for (int i = 31; i >= 1; i -= 2)
//	{
//		printf("%d ", (num >> i) & 1);
//	}
//	printf("\n");
//
//	for (int i = 30; i >= 0; i -= 2)
//	{
//		printf("%d ", (num >> i) & 1);
//	}
//	printf("\n");
//}
//int main()
//{
//	int a;
//	scanf("%d", &a);
//	Printbit(a);
//	return 0;
//}

//练习：统计二进制中1的个数
//int Sum_One(int n)
//{
//	int i, count = 0;
//	for ( i = 0; i < 32; i++)
//	{
//		if (((n >> i) & 1)==1)
//			count++;
//	}
//	return count;
//}
//int main()
//{
//	int a,count;
//	printf("请输入数据：\n");
//	scanf("%d", &a);
//	count = Sum_One(a);
//	printf("%d", count);
//}
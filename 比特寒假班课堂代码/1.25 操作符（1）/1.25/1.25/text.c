#define _CRT_SECURE_NO_WARNINGS
#include <stdio.h>

//操作符

//算术操作符 重点讲一下 / %

//int main()
//{
//	//除号操作符的2个操作数都是整数，执行的是整数除法
//	//除号的操作符有一个数是浮点数，则执行浮点数除法
//	printf("%d\n", 7 / 2);
//	printf("%lf\n", 7 / 2.0);
//	//printf("%lf\n", 7 / 0);error
//	
//	//取模
//	printf("%d\n", 7 % 2);//取模即取余数 ，操作数要是整数
//	return 0;
//}

//移位操作符  移动二进制位

//<<  左移
//int main()
//{
//	int a = 5;
//	//00000000000000000000000000000101
//	//左移1位后
//	//00000000000000000000000000001010
//	//结果为10
//	int b = a << 1;
//	// 左移，移动的其实是二进制位
//	//a的二进制位
//	//整数的二进制有三种表示：原码，反码和补码，电脑内存储的是补码
//	//正数三码相同
//	//负数要计算，笔记上~~
//	printf("%d\n", b);
//	int a = -1;
//	//10000000000000000000000000000001-原码
//	//11111111111111111111111111111110-反码
//	//11111111111111111111111111111111-补码
//	int b = a << 1;
//	//11111111111111111111111111111110-补码
//	//11111111111111111111111111111101-反码
//	//10000000000000000000000000000010-原码
//	//结果为-2
//	printf("%d\n", b);
//	//综上所示，左移操作符左边抛弃，右边补1，并且左移有乘2效果
//	return 0;
//
//}

//>>
//右移分两种
//算术右移：左边用原来值符号位填充，右边抛弃  算术右移有除2的效果（偶数明显）
//逻辑右移：左边用0填充，右边抛弃
//我们现在使用的visual studio是用算术右移，这些是编译器所决定的
//int main()
//{
//	int  a = -1;
	//10000000000000000000000000000001-原码
	//11111111111111111111111111111110-反码
	//11111111111111111111111111111111-补码
	//int b = a >> 1;
	//11111111111111111111111111111111-补码
	//11111111111111111111111111111110-反码
	//10000000000000000000000000000001-原码
	//结果为-1
//}

//位操作符
//&按位与
//|按位或
//^按位异或，相同为0，相异为1
//笔记~~
//int main()
//{
//	int a = 3;
//	//00000000000000000000000000000011
//	int b = 5;
//	//00000000000000000000000000000101
//	int c = a & b;
//	//00000000000000000000000000000001  结果为1
//	int d = a | b;
//	//00000000000000000000000000000111  结果为7
//	int e = a ^ b;
//	//00000000000000000000000000000110  结果为6
//
//	printf("%d\n", c);
//	printf("%d\n", d);
//	printf("%d\n", e);
//}

//交换两个变量
//int main()
//{
//	int a = 3;
//	int b = 5;
//	int tmp = 0;
//	printf("a=%d b=%d\n", a, b);
//	tmp = a;
//	a = b;
//	b = tmp;
//	printf("a=%d b=%d\n", a, b);
//	return 0;
//}

//如果要求交化两个整数，不能使用第三个变量
//int main()
//{
//	int a = 3;
//	int b = 5;
//	printf("a=%d b=%d\n", a, b);
//	a = a + b;
//	b = a - b;//b=3
//	a = a - b;//a=5
//	printf("a=%d b=%d\n", a, b);
//	//缺点在于可能整形溢出
//	return 0;
//}

//优化
//int main()
//{
//	int a = 3;
//	int b = 5;
//	printf("a=%d b=%d\n", a, b);
//	a = a ^ b;
//	b = a ^ b;
//	a = a ^ b;
//	printf("a=%d b=%d\n", a, b);
//	//异或结果可以认为是加密， a和b异或加密得到密码
//	//密码在和原来的b异或解密则得到a，密码在和原来的a异或解密得到b
//	return 0;
//}

//但实际上写代码肯定写方法一，方法三可读性太差，且效率不高

//练习：写一个函数返回参数二进制中 1 的个数

//最先想到的写法，但存在问题
//int count_one_bit(int n)
//{
//	int count = 0;
//	while (n)
//	{
//		if (n % 2 == 1)//虽然用十进制算，但是实际上和二进制算是一样
//		{
//			count++;
//		}
//		n = n / 2;
//	}
//	return count;
//}

//优化
//int count_one_bit(int n)
//{
//	int count = 0, i;
//	for (i = 0; i < 32; i++)
//	{
//		if (（(n >> i) & 1) == 1)
//		count++;
//	}
//	return count;
//}

//最优解
//int count_one_bit(int n)
//{
//	int count = 0;
//	while (n)
//	{
//		n = n & (n - 1);//因为n&n-1都会将最右边的1消去，这样一直循环下去，可以将其全变为0
//		count++;
//	}
//	return count;
//}

//赋值
//int main()
//{
//	int a = 15;//这叫初始化  不是赋值
//	a = 20;//赋值
//	int x = 0;
//	int y = 20;
//	a = x = y + 1;//连续赋值，但是很挫，不宜观察
//	
//	x = y + 1;
//	a = x;
//}
//复合赋值 ~~~

//单目操作符，
//重点讲！ & * sizeof
//int main()
//{
//	int condition;
//	if (!condition)//不符合条件做什么
//	{
//		;
//	}
//	if (condition)//符合条件做什么
//	{
//		;
//	}
//  当然这种情况是要求对condition真假判断才有用

//}

//int main()
//{
//	int a = -3;
//	a = -a;
//	a = +a;//+几乎没用
//	return 0;
//}
//int main()
//{
//	//注意 & * 在不同作用场景意义不同，比如*可以表示乘法
//	int a = -3;
//	int*p = &a;//&取地址操作符
//	*p = 30;//*解引用操作符 或者叫间接访问操作符
//	return 0;
//}

//int main()
//{
//	int a = 10;
//	printf("%d\n", sizeof(a));
//	printf("%d\n", sizeof a);//可以去掉括号，从这个角度来讲sizeof是一个操作符不是函数，函数不可以省去括号
//	printf("%d\n", sizeof(int));
//	//sizeof计算类型所占内存大小，单位字节  
//	int arr[10] = { 0 };
//	printf("%d\n", sizeof(arr));
//	printf("%d\n", sizeof(int[10]));
//
//}
//int main()
//{
//	short s = 3;
//	int a = 10;
//	printf("%d\n", sizeof(s = a + 5));//2
//	printf("%d\n", s);//3  sizeof括号内放的表达式是不计算的，因为sizeof计算在编译过程，而赋值计算是在运行阶段，而在运行阶段，sizeof已经计算完了
//}



